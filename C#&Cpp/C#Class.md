类可以定义有参构造函数，以便其初始化，

因此在实例化时， Myclass myclass1 = new Myclass（）；

括号里就是有参构造函数的参数，若是无参，也要有括号，里边空着即可


-----
5、静态成员与静态类Static

  Static成员和成员函数无须创建实例即可访问

    且通过对象访问同一个类的所有实例的同一静态变量都是同一个值（共享分配在全局区的内存）


  静态成员函数只能通过类访问而不是实例对象访问，且静态成员函数不能访问非静态数据成员

  Static静态类，不得被继承，仅包含静态成员或常量

    一般用于工具类

    不能被实例化，不能包含实例构造函数，但可以包含静态构造函数




-----
**关于静态构造函数**

- 静态构造函数不可被调用（框架会在合适的时候自动调用）
- 无public、private等关键字修饰，因为无须自己调用
- 没有参数
- 不能实例化实例变量
- 一个类中唯一一个
- 若类中定义了静态变量却无静态构造函数，会自动生成一个
- 顺序：优先对静态变量初始化，然后在创建第一个实例对象或调用任何静态变量之前，调用静态构造函数，==且只调用一次==


-----
**关于常量**

Const

- 在类内声明的const常量，外部访问时，必须通过类名访问，且无法修改
- 只有在声明时才能初始化，不允许在任何地方包括构造函数对其进行初始化

readonly

- 不能与const共同修饰同一个数据类型
- 可以通过类的实例进行访问，但无法进行修改
- 仅可以在声明时初始化以及在构造函数中初始化

访问修饰符

  形如 *public int myValue { get；private set；}*

  public 修饰get，表示访问该数据的权限，private修饰set，表示修改该数据的权限

  以及形如


*public int myValue*

*{*

*get*

  *{return my\_Value1；}*


*（private） set*

*{myValue=value；}*

*}*

表示访问时，变量值为my\_Value1的值，对其修改时，则将其修改为赋的value值


-----
6、抽象类abstract

提炼出一些类共有的属性或函数接口，为子类提供设计思想，配合多态用于代码架构设计

- 抽象类无法被实例化
- 允许提供部分函数的具体实现，也可仅声明抽象函数
- 抽象类支持构造函数和静态构造函数
- 允许virtual虚函数
- 抽象类中用abstract关键字修饰的抽象函数，不能有函数体，而继承该抽象类的子类，必须显式地覆盖（override）父类的方法
- 类方法的访问修饰符默认是private，可以自行限定为其他，如果是abstract抽象方法，不允许是private


-----
7、密封类sealed

一般用于防止重写某些类或接口影响功能的稳定

- 不能被继承，但是可以继承别的类或接口
- 密封类不可以声明为抽象类
- 密封类内的成员函数，不得声明为sealed


-----
8、泛型类

用于处理一组功能一样仅类型不同的任务

- 类名后可以添加<T1,T2,T3…>,使类变为一个泛型类，泛型T1,T2,T3可以通过where关键字来指定泛型类型约束

Public class Myclass<T>where T:Anytype

且有效的约束T必须是

- Where T :class | T必须是一个类
- Where T :struct | T必须是一个结构类型
- Where T :new（） | T必须是一个无参数的构造函数
- Where T :NameOfBaseClass（） | T必须继承名为NameOfBaseClass的类
- Where T :NameOfIneterface（） | T必须实现名为NameOfInterfcae的接口

- 在声明时可以不指定具体的类型，但在new实例化时必须指定类型
- 如果子类也是泛型的，那么继承时可以不指定具体类型
  - public class TestChild : Test< string, int>{ } //表示子类是非泛型类，同时具体化了父类的泛型为string，int
  - public class TestChild< T, S> : Test< T, S> { } //表示子类是泛型类，且父类的泛型仍未具体化，且二者**__共用__**T,S
  - public class TestChild< T, S> : Test< String, int> { } //表示子类是泛型类，具体化了父类的泛型仍未具体化，子类使用泛型T,S


即用T来代替具体的数据类型，在调用时再具体化，就像C++中的函数模版一样,

并且C#也支持泛型方法，泛型委托

